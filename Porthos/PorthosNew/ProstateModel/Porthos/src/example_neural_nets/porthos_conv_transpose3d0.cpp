/*
This is an autogenerated file, generated using the EzPC compiler.
*/
#include "globals.h"

#include<vector>
#include<math.h>
#include<cstdlib>
#include<iostream>
#include<fstream>
#include <cstdlib>
#include "EzPCFunctionalities.h"

using namespace std;


void funcConv3DMPC(
        int32_t N,
        int32_t D,
        int32_t H,
        int32_t W,
        int32_t CI,
        int32_t FD,
        int32_t FH,
        int32_t FW,
        int32_t CO,
        int32_t zPadDLeft,
        int32_t zPadDRight,
        int32_t zPadHLeft,
        int32_t zPadHRight,
        int32_t zPadWLeft,
        int32_t zPadWRight,
        int32_t strideD,
        int32_t strideH,
        int32_t strideW,
        vector< vector< vector< vector< vector<porthosSecretType> > > > >& inputArr,
        vector< vector< vector< vector< vector<porthosSecretType> > > > >& filterArr,
        int32_t consSF,
        vector< vector< vector< vector< vector<porthosSecretType> > > > >& outArr);

uint32_t public_lrshift(uint32_t x, uint32_t y){
return (x >> y);
}

int32_t public_lrshift(int32_t x, uint32_t y){
return ((int32_t)(((uint32_t)x) >> y));
}

uint64_t public_lrshift(uint64_t x, uint64_t y){
return (x >> y);
}

int64_t public_lrshift(int64_t x, uint64_t y){
return ((int64_t)(((uint64_t)x) >> y));
}

template<typename T>
vector<T> make_vector(size_t size) {
return std::vector<T>(size);
}

template <typename T, typename... Args>
auto make_vector(size_t first, Args... sizes)
{
auto inner = make_vector<T>(sizes...);
return vector<decltype(inner)>(first, inner);
}

template<typename T>
ostream& operator<< (ostream &os, const vector<T> &v)
{
for(auto it = v.begin (); it != v.end (); ++it) {
os << *it << endl;
}
return os;
}


#include "ezpc.h"

extern int partyNum;
vector<uint64_t*> toFreeMemoryLaterArr;
int NUM_OF_PARTIES;

AESObject* aes_common;
AESObject* aes_indep;
AESObject* aes_a_1;
AESObject* aes_a_2;
AESObject* aes_b_1;
AESObject* aes_b_2;
AESObject* aes_c_1;
AESObject* aes_share_conv_bit_shares_p0_p2;
AESObject* aes_share_conv_bit_shares_p1_p2;
AESObject* aes_share_conv_shares_mod_odd_p0_p2;
AESObject* aes_share_conv_shares_mod_odd_p1_p2;
AESObject* aes_comp_msb_shares_lsb_p0_p2;
AESObject* aes_comp_msb_shares_lsb_p1_p2;
AESObject* aes_comp_msb_shares_bit_vec_p0_p2;
AESObject* aes_comp_msb_shares_bit_vec_p1_p2;
AESObject* aes_conv_opti_a_1;
AESObject* aes_conv_opti_a_2;
AESObject* aes_conv_opti_b_1;
AESObject* aes_conv_opti_b_2;
AESObject* aes_conv_opti_c_1;
ParallelAESObject* aes_parallel;























void MatAddBroadCast2(int32_t a1, int32_t a2, int32_t b1, int32_t s1, int32_t s2, auto& A, auto& B, auto& outArr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
outArr[i1][i2] = A[i1][i2]+B[i2];
}
}
}

void MatAdd2(int32_t a1, int32_t a2, int32_t b1, int32_t b2, int32_t s1, int32_t s2, auto& A, auto& B, auto& outArr){

int32_t aIdx1 =  (int32_t)0;

int32_t aIdx2 =  (int32_t)0;

int32_t bIdx1 =  (int32_t)0;

int32_t bIdx2 =  (int32_t)0;
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
aIdx1 = (a1 ==  (int32_t)1) ?  (int32_t)0 : i1;
bIdx1 = (b1 ==  (int32_t)1) ?  (int32_t)0 : i1;
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
aIdx2 = (a2 ==  (int32_t)1) ?  (int32_t)0 : i2;
bIdx2 = (b2 ==  (int32_t)1) ?  (int32_t)0 : i2;
outArr[i1][i2] = A[aIdx1][aIdx2]+B[bIdx1][bIdx2];
}
}
}

void MatAddBroadCast4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t b1, int32_t s1, int32_t s2, int32_t s3, int32_t s4, auto& A, auto& B, auto& outArr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
outArr[i1][i2][i3][i4] = A[i1][i2][i3][i4]+B[i4];
}
}
}
}
}

void MatAddBroadCast5(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t b1, int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t s5, auto& A, auto& B, auto& outArr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
for (uint32_t i5 =  (int32_t)0; i5 < s5; i5++){
outArr[i1][i2][i3][i4][i5] = A[i1][i2][i3][i4][i5]+B[i5];
}
}
}
}
}
}

void MatAdd4(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t b1, int32_t b2, int32_t b3, int32_t b4, int32_t s1, int32_t s2, int32_t s3, int32_t s4, auto& A, auto& B, auto& outArr){

int32_t aIdx1 =  (int32_t)0;

int32_t aIdx2 =  (int32_t)0;

int32_t aIdx3 =  (int32_t)0;

int32_t aIdx4 =  (int32_t)0;

int32_t bIdx1 =  (int32_t)0;

int32_t bIdx2 =  (int32_t)0;

int32_t bIdx3 =  (int32_t)0;

int32_t bIdx4 =  (int32_t)0;
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
aIdx1 = (a1 ==  (int32_t)1) ?  (int32_t)0 : i1;
bIdx1 = (b1 ==  (int32_t)1) ?  (int32_t)0 : i1;
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
aIdx2 = (a2 ==  (int32_t)1) ?  (int32_t)0 : i2;
bIdx2 = (b2 ==  (int32_t)1) ?  (int32_t)0 : i2;
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
aIdx3 = (a3 ==  (int32_t)1) ?  (int32_t)0 : i3;
bIdx3 = (b3 ==  (int32_t)1) ?  (int32_t)0 : i3;
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
aIdx4 = (a4 ==  (int32_t)1) ?  (int32_t)0 : i4;
bIdx4 = (b4 ==  (int32_t)1) ?  (int32_t)0 : i4;
outArr[i1][i2][i3][i4] = A[aIdx1][aIdx2][aIdx3][aIdx4]+B[bIdx1][bIdx2][bIdx3][bIdx4];
}
}
}
}
}

void MatAdd5(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t b1, int32_t b2, int32_t b3, int32_t b4, int32_t b5, int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t s5, auto& A, auto& B, auto& outArr){

int32_t aIdx1 =  (int32_t)0;

int32_t aIdx2 =  (int32_t)0;

int32_t aIdx3 =  (int32_t)0;

int32_t aIdx4 =  (int32_t)0;

int32_t aIdx5 =  (int32_t)0;

int32_t bIdx1 =  (int32_t)0;

int32_t bIdx2 =  (int32_t)0;

int32_t bIdx3 =  (int32_t)0;

int32_t bIdx4 =  (int32_t)0;

int32_t bIdx5 =  (int32_t)0;
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
aIdx1 = (a1 ==  (int32_t)1) ?  (int32_t)0 : i1;
bIdx1 = (b1 ==  (int32_t)1) ?  (int32_t)0 : i1;
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
aIdx2 = (a2 ==  (int32_t)1) ?  (int32_t)0 : i2;
bIdx2 = (b2 ==  (int32_t)1) ?  (int32_t)0 : i2;
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
aIdx3 = (a3 ==  (int32_t)1) ?  (int32_t)0 : i3;
bIdx3 = (b3 ==  (int32_t)1) ?  (int32_t)0 : i3;
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
aIdx4 = (a4 ==  (int32_t)1) ?  (int32_t)0 : i4;
bIdx4 = (b4 ==  (int32_t)1) ?  (int32_t)0 : i4;
for (uint32_t i5 =  (int32_t)0; i5 < s5; i5++){
aIdx5 = (a5 ==  (int32_t)1) ?  (int32_t)0 : i5;
bIdx5 = (b5 ==  (int32_t)1) ?  (int32_t)0 : i5;
outArr[i1][i2][i3][i4][i5] = A[aIdx1][aIdx2][aIdx3][aIdx4][aIdx5]+B[bIdx1][bIdx2][bIdx3][bIdx4][bIdx5];
}
}
}
}
}
}

void CreateTensor1(int32_t s1, int64_t val, auto& arr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
arr[i1] = val;
}
}

void CreateTensor2(int32_t s1, int32_t s2, int64_t val, auto& arr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
arr[i1][i2] = val;
}
}
}

void CreateTensor4(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int64_t val, auto& arr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
arr[i1][i2][i3][i4] = val;
}
}
}
}
}

void CreateTensor5(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t s5, int64_t val, auto& arr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
for (uint32_t i5 =  (int32_t)0; i5 < s5; i5++){
arr[i1][i2][i3][i4][i5] = val;
}
}
}
}
}
}

void CopyTensor1(int32_t s1, auto& targetArr, auto& fromArr, auto& ignore){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
targetArr[i1] = fromArr[i1];
}
}

void CopyTensor2(int32_t s1, int32_t s2, auto& targetArr, auto& fromArr, auto& ignore){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
targetArr[i1][i2] = fromArr[i1][i2];
}
}
}

void CopyTensor4(int32_t s1, int32_t s2, int32_t s3, int32_t s4, auto& targetArr, auto& fromArr, auto& ignore){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
targetArr[i1][i2][i3][i4] = fromArr[i1][i2][i3][i4];
}
}
}
}
}

void CreateIdentity11(int32_t s1, auto& fromArr, auto& newArr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
newArr[i1] = fromArr[i1];
}
}

void CreateIdentity22(int32_t s1, int32_t s2, auto& fromArr, auto& newArr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
newArr[i1][i2] = fromArr[i1][i2];
}
}
}

void CreateIdentity44(int32_t s1, int32_t s2, int32_t s3, int32_t s4, auto& fromArr, auto& newArr){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
newArr[i1][i2][i3][i4] = fromArr[i1][i2][i3][i4];
}
}
}
}
}

void CreateCopy2211(int32_t s1, int32_t s2, int32_t inps1, int32_t inps2, auto& inArr, int32_t perDimSize, auto& beginIdx, auto& sizeIdx, auto& outArr){
for (uint32_t i =  (int32_t)0; i < s1; i++){
for (uint32_t j =  (int32_t)0; j < s2; j++){
outArr[i][j] = inArr[(beginIdx[ (int32_t)0] + i)][(beginIdx[ (int32_t)1] + j)];
}
}
}

void CreateCopy5511(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t s5, int32_t inps1, int32_t inps2, int32_t inps3, int32_t inps4, int32_t inps5, auto& inArr, int32_t perDimSize, auto& beginIdx, auto& sizeIdx, auto& outArr){
for (uint32_t i =  (int32_t)0; i < s1; i++){
for (uint32_t j =  (int32_t)0; j < s2; j++){
for (uint32_t k =  (int32_t)0; k < s3; k++){
for (uint32_t l =  (int32_t)0; l < s4; l++){
for (uint32_t m =  (int32_t)0; m < s5; m++){
outArr[i][j][k][l][m] = inArr[(beginIdx[ (int32_t)0] + i)][(beginIdx[ (int32_t)1] + j)][(beginIdx[ (int32_t)2] + k)][(beginIdx[ (int32_t)3] + l)][(beginIdx[ (int32_t)4] + m)];
}
}
}
}
}
}

void Concat2T444(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t inp1s1, int32_t inp1s2, int32_t inp1s3, int32_t inp1s4, auto& inp1, int32_t inp2s1, int32_t inp2s2, int32_t inp2s3, int32_t inp2s4, auto& inp2, int32_t axis, auto& outp){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
for (uint32_t i3 =  (int32_t)0; i3 < s3; i3++){
for (uint32_t i4 =  (int32_t)0; i4 < s4; i4++){
if ((axis ==  (int32_t)0)) {
if ((i1 < inp1s1)) {
outp[i1][i2][i3][i4] = inp1[i1][i2][i3][i4];
} else {
outp[i1][i2][i3][i4] = inp2[(i1 - inp1s1)][i2][i3][i4];
}
} else {
if ((axis ==  (int32_t)1)) {
if ((i2 < inp1s2)) {
outp[i1][i2][i3][i4] = inp1[i1][i2][i3][i4];
} else {
outp[i1][i2][i3][i4] = inp2[i1][(i2 - inp1s2)][i3][i4];
}
} else {
if ((axis ==  (int32_t)2)) {
if ((i3 < inp1s3)) {
outp[i1][i2][i3][i4] = inp1[i1][i2][i3][i4];
} else {
outp[i1][i2][i3][i4] = inp2[i1][i2][(i3 - inp1s3)][i4];
}
} else {
if ((i4 < inp1s4)) {
outp[i1][i2][i3][i4] = inp1[i1][i2][i3][i4];
} else {
outp[i1][i2][i3][i4] = inp2[i1][i2][i3][(i4 - inp1s4)];
}
}
}
}
}
}
}
}
}

void Concat2T222(int32_t s1, int32_t s2, int32_t inp1s1, int32_t inp1s2, auto& inp1, int32_t inp2s1, int32_t inp2s2, auto& inp2, int32_t axis, auto& outp){
for (uint32_t i1 =  (int32_t)0; i1 < s1; i1++){
for (uint32_t i2 =  (int32_t)0; i2 < s2; i2++){
if ((axis ==  (int32_t)0)) {
if ((i1 < inp1s1)) {
outp[i1][i2] = inp1[i1][i2];
} else {
outp[i1][i2] = inp2[(i1 - inp1s1)][i2];
}
} else {
if ((i2 < inp1s2)) {
outp[i1][i2] = inp1[i1][i2];
} else {
outp[i1][i2] = inp2[i1][(i2 - inp1s2)];
}
}
}
}
}

void Split44(int32_t O1, int32_t O2, int32_t O3, int32_t O4, int32_t I1, int32_t I2, int32_t I3, int32_t I4, auto& inp, int32_t axis, int32_t curCount, int32_t total, auto& out){
for (uint32_t o1 =  (int32_t)0; o1 < O1; o1++){
for (uint32_t o2 =  (int32_t)0; o2 < O2; o2++){
for (uint32_t o3 =  (int32_t)0; o3 < O3; o3++){
for (uint32_t o4 =  (int32_t)0; o4 < O4; o4++){

int32_t i1 = o1;

int32_t i2 = o2;

int32_t i3 = o3;

int32_t i4 = o4;
if ((axis ==  (int32_t)0)) {
i1 = (((I1 / total) * curCount) + o1);
}
if ((axis ==  (int32_t)1)) {
i2 = (((I2 / total) * curCount) + o2);
}
if ((axis ==  (int32_t)2)) {
i3 = (((I3 / total) * curCount) + o3);
}
if ((axis ==  (int32_t)3)) {
i4 = (((I4 / total) * curCount) + o4);
}
out[o1][o2][o3][o4] = inp[i1][i2][i3][i4];
}
}
}
}
}

void Conv2DReshapeFilter(int32_t FH, int32_t FW, int32_t CI, int32_t CO, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){

int32_t linIdx = ((((fh * FW) * CI) + (fw * CI)) + ci);
outputArr[co][linIdx] = inputArr[fh][fw][ci][co];
}
}
}
}
}

void Conv2DReshapeMatMulOP(int32_t N, int32_t finalH, int32_t finalW, int32_t CO, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t n =  (int32_t)0; n < N; n++){
for (uint32_t h =  (int32_t)0; h < finalH; h++){
for (uint32_t w =  (int32_t)0; w < finalW; w++){
outputArr[n][h][w][co] = inputArr[co][((((n * finalH) * finalW) + (h * finalW)) + w)];
}
}
}
}
}

void Conv2DReshapeInput(int32_t N, int32_t H, int32_t W, int32_t CI, int32_t FH, int32_t FW, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideH, int32_t strideW, int32_t RRows, int32_t RCols, auto& inputArr, auto& outputArr){

int32_t linIdxFilterMult =  (int32_t)0;
for (uint32_t n =  (int32_t)0; n < N; n++){

int32_t leftTopCornerH = ( (int32_t)0 - zPadHLeft);

int32_t extremeRightBottomCornerH = ((H -  (int32_t)1) + zPadHRight);
while ((((leftTopCornerH + FH) -  (int32_t)1) <= extremeRightBottomCornerH)) {

int32_t leftTopCornerW = ( (int32_t)0 - zPadWLeft);

int32_t extremeRightBottomCornerW = ((W -  (int32_t)1) + zPadWRight);
while ((((leftTopCornerW + FW) -  (int32_t)1) <= extremeRightBottomCornerW)) {
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){

int32_t curPosH = (leftTopCornerH + fh);

int32_t curPosW = (leftTopCornerW + fw);

uint64_t val = funcSSCons( (int64_t)0);
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){
if ((((curPosH <  (int32_t)0) || (curPosH >= H)) || ((curPosW <  (int32_t)0) || (curPosW >= W)))) {
val = funcSSCons( (int64_t)0);
} else {
val = inputArr[n][curPosH][curPosW][ci];
}
outputArr[((((fh * FW) * CI) + (fw * CI)) + ci)][linIdxFilterMult] = val;
}
}
}
linIdxFilterMult = (linIdxFilterMult +  (int32_t)1);
leftTopCornerW = (leftTopCornerW + strideW);
}

leftTopCornerH = (leftTopCornerH + strideH);
}

}
}

void Conv2DCSF(int32_t N, int32_t H, int32_t W, int32_t CI, int32_t FH, int32_t FW, int32_t CO, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideH, int32_t strideW, auto& inputArr, auto& filterArr, int32_t consSF, auto& outArr){

int32_t reshapedFilterRows = CO;

int32_t reshapedFilterCols = ((FH * FW) * CI);

int32_t reshapedIPRows = ((FH * FW) * CI);

int32_t newH = ((((H + (zPadHLeft + zPadHRight)) - FH) / strideH) +  (int32_t)1);

int32_t newW = ((((W + (zPadWLeft + zPadWRight)) - FW) / strideW) +  (int32_t)1);

int32_t reshapedIPCols = ((N * newH) * newW);

auto filterReshaped = make_vector<uint64_t>(reshapedFilterRows, reshapedFilterCols);

auto inputReshaped = make_vector<uint64_t>(reshapedIPRows, reshapedIPCols);

auto matmulOP = make_vector<uint64_t>(reshapedFilterRows, reshapedIPCols);
Conv2DReshapeFilter(FH, FW, CI, CO, filterArr, filterReshaped);
Conv2DReshapeInput(N, H, W, CI, FH, FW, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, strideH, strideW, reshapedIPRows, reshapedIPCols, inputArr, inputReshaped);
MatMulCSF2D(reshapedFilterRows, reshapedFilterCols, reshapedIPCols, filterReshaped, inputReshaped, matmulOP, consSF);
Conv2DReshapeMatMulOP(N, newH, newW, CO, matmulOP, outArr);
}

void Conv2DReshapeFilterGroup(int32_t FH, int32_t FW, int32_t CI, int32_t CO, int32_t g, int32_t G, auto& inputArr, auto& outputArr){

int32_t CIG = (CI / G);

int32_t COG = (CO / G);

int32_t startCO = (g * COG);
for (uint32_t co =  (int32_t)0; co < COG; co++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){
for (uint32_t ci =  (int32_t)0; ci < CIG; ci++){

int32_t linIdx = ((((fh * FW) * CIG) + (fw * CIG)) + ci);
outputArr[co][linIdx] = inputArr[fh][fw][ci][(co + startCO)];
}
}
}
}
}

void Conv2DReshapeMatMulOPGroup(int32_t N, int32_t finalH, int32_t finalW, int32_t CO, int32_t g, int32_t G, auto& inputArr, auto& outputArr){

int32_t COG = (CO / G);

int32_t startCO = (g * COG);
for (uint32_t co =  (int32_t)0; co < COG; co++){
for (uint32_t n =  (int32_t)0; n < N; n++){
for (uint32_t h =  (int32_t)0; h < finalH; h++){
for (uint32_t w =  (int32_t)0; w < finalW; w++){
outputArr[n][h][w][(co + startCO)] = inputArr[co][((((n * finalH) * finalW) + (h * finalW)) + w)];
}
}
}
}
}

void Conv2DReshapeInputGroup(int32_t N, int32_t H, int32_t W, int32_t CI, int32_t FH, int32_t FW, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideH, int32_t strideW, int32_t g, int32_t G, int32_t RRows, int32_t RCols, auto& inputArr, auto& outputArr){

int32_t linIdxFilterMult =  (int32_t)0;

int32_t CIG = (CI / G);
for (uint32_t n =  (int32_t)0; n < N; n++){

int32_t leftTopCornerH = ( (int32_t)0 - zPadHLeft);

int32_t extremeRightBottomCornerH = ((H -  (int32_t)1) + zPadHRight);
while ((((leftTopCornerH + FH) -  (int32_t)1) <= extremeRightBottomCornerH)) {

int32_t leftTopCornerW = ( (int32_t)0 - zPadWLeft);

int32_t extremeRightBottomCornerW = ((W -  (int32_t)1) + zPadWRight);
while ((((leftTopCornerW + FW) -  (int32_t)1) <= extremeRightBottomCornerW)) {
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){

int32_t curPosH = (leftTopCornerH + fh);

int32_t curPosW = (leftTopCornerW + fw);

uint64_t val = funcSSCons( (int64_t)0);

int32_t startCI = (g * CIG);
for (uint32_t ci =  (int32_t)0; ci < CIG; ci++){
if ((((curPosH <  (int32_t)0) || (curPosH >= H)) || ((curPosW <  (int32_t)0) || (curPosW >= W)))) {
val = funcSSCons( (int64_t)0);
} else {
val = inputArr[n][curPosH][curPosW][(ci + startCI)];
}
outputArr[((((fh * FW) * CIG) + (fw * CIG)) + ci)][linIdxFilterMult] = val;
}
}
}
linIdxFilterMult = (linIdxFilterMult +  (int32_t)1);
leftTopCornerW = (leftTopCornerW + strideW);
}

leftTopCornerH = (leftTopCornerH + strideH);
}

}
}

void Conv2DCSFGroup(int32_t N, int32_t H, int32_t W, int32_t CI, int32_t FH, int32_t FW, int32_t CO, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideH, int32_t strideW, int32_t G, auto& inputArr, auto& filterArr, int32_t consSF, auto& outArr){

int32_t CIG = (CI / G);

int32_t reshapedFilterRows = (CO / G);

int32_t reshapedFilterCols = ((FH * FW) * CIG);

int32_t reshapedIPRows = ((FH * FW) * CIG);

int32_t outH = ((((H + (zPadHLeft + zPadHRight)) - FH) / strideH) +  (int32_t)1);

int32_t outW = ((((W + (zPadWLeft + zPadWRight)) - FW) / strideW) +  (int32_t)1);

int32_t reshapedIPCols = ((N * outH) * outW);
for (uint32_t g =  (int32_t)0; g < G; g++){

auto inputReshaped = make_vector<uint64_t>(reshapedIPRows, reshapedIPCols);

auto matmulOP = make_vector<uint64_t>(reshapedFilterRows, reshapedIPCols);

auto filterReshaped = make_vector<uint64_t>(reshapedFilterRows, reshapedFilterCols);
Conv2DReshapeFilterGroup(FH, FW, CI, CO, g, G, filterArr, filterReshaped);
Conv2DReshapeInputGroup(N, H, W, CI, FH, FW, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, strideH, strideW, g, G, reshapedIPRows, reshapedIPCols, inputArr, inputReshaped);
MatMulCSF2D(reshapedFilterRows, reshapedFilterCols, reshapedIPCols, filterReshaped, inputReshaped, matmulOP, consSF);
Conv2DReshapeMatMulOPGroup(N, outH, outW, CO, g, G, matmulOP, outArr);
}
}

void Conv3DReshapeFilter(int32_t FD, int32_t FH, int32_t FW, int32_t CI, int32_t CO, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t fd =  (int32_t)0; fd < FD; fd++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){

int32_t linIdx = ((((((fd * FH) * FW) * CI) + ((fh * FW) * CI)) + (fw * CI)) + ci);
outputArr[co][linIdx] = inputArr[fd][fh][fw][ci][co];
}
}
}
}
}
}

void Conv3DReshapeMatMulOP(int32_t N, int32_t finalD, int32_t finalH, int32_t finalW, int32_t CO, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t n =  (int32_t)0; n < N; n++){
for (uint32_t d =  (int32_t)0; d < finalD; d++){
for (uint32_t h =  (int32_t)0; h < finalH; h++){
for (uint32_t w =  (int32_t)0; w < finalW; w++){
outputArr[n][d][h][w][co] = inputArr[co][((((((n * finalD) * finalH) * finalW) + ((d * finalH) * finalW)) + (h * finalW)) + w)];
}
}
}
}
}
}

void Conv3DReshapeInput(int32_t N, int32_t D, int32_t H, int32_t W, int32_t CI, int32_t FD, int32_t FH, int32_t FW, int32_t zPadDLeft, int32_t zPadDRight, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideD, int32_t strideH, int32_t strideW, int32_t RRows, int32_t RCols, auto& inputArr, auto& outputArr){

int32_t linIdxFilterMult =  (int32_t)0;
for (uint32_t n =  (int32_t)0; n < N; n++){

int32_t leftTopCornerD = ( (int32_t)0 - zPadDLeft);

int32_t extremeRightBottomCornerD = ((D -  (int32_t)1) + zPadDRight);
while ((((leftTopCornerD + FD) -  (int32_t)1) <= extremeRightBottomCornerD)) {

int32_t leftTopCornerH = ( (int32_t)0 - zPadHLeft);

int32_t extremeRightBottomCornerH = ((H -  (int32_t)1) + zPadHRight);
while ((((leftTopCornerH + FH) -  (int32_t)1) <= extremeRightBottomCornerH)) {

int32_t leftTopCornerW = ( (int32_t)0 - zPadWLeft);

int32_t extremeRightBottomCornerW = ((W -  (int32_t)1) + zPadWRight);
while ((((leftTopCornerW + FW) -  (int32_t)1) <= extremeRightBottomCornerW)) {
for (uint32_t fd =  (int32_t)0; fd < FD; fd++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){

int32_t curPosD = (leftTopCornerD + fd);

int32_t curPosH = (leftTopCornerH + fh);

int32_t curPosW = (leftTopCornerW + fw);

uint64_t val = funcSSCons( (int64_t)0);
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){
if (((((curPosD <  (int32_t)0) || (curPosD >= D)) || ((curPosH <  (int32_t)0) || (curPosH >= H))) || ((curPosW <  (int32_t)0) || (curPosW >= W)))) {
val = funcSSCons( (int64_t)0);
} else {
val = inputArr[n][curPosD][curPosH][curPosW][ci];
}
outputArr[((((((fd * FH) * FW) * CI) + ((fh * FW) * CI)) + (fw * CI)) + ci)][linIdxFilterMult] = val;
}
}
}
}
linIdxFilterMult = (linIdxFilterMult +  (int32_t)1);
leftTopCornerW = (leftTopCornerW + strideW);
}

leftTopCornerH = (leftTopCornerH + strideH);
}

leftTopCornerD = (leftTopCornerD + strideD);
}

}
}

void Conv3DCSF(int32_t N, int32_t D, int32_t H, int32_t W, int32_t CI, int32_t FD, int32_t FH, int32_t FW, int32_t CO, int32_t zPadDLeft, int32_t zPadDRight, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideD, int32_t strideH, int32_t strideW, auto& inputArr, auto& filterArr, int32_t consSF, auto& outArr){

int32_t reshapedFilterRows = CO;

int32_t reshapedFilterCols = (((FD * FH) * FW) * CI);

int32_t reshapedIPRows = (((FD * FH) * FW) * CI);

int32_t newD = ((((D + (zPadDLeft + zPadDRight)) - FD) / strideD) +  (int32_t)1);

int32_t newH = ((((H + (zPadHLeft + zPadHRight)) - FH) / strideH) +  (int32_t)1);

int32_t newW = ((((W + (zPadWLeft + zPadWRight)) - FW) / strideW) +  (int32_t)1);

int32_t reshapedIPCols = (((N * newD) * newH) * newW);

auto filterReshaped = make_vector<uint64_t>(reshapedFilterRows, reshapedFilterCols);

auto inputReshaped = make_vector<uint64_t>(reshapedIPRows, reshapedIPCols);

auto matmulOP = make_vector<uint64_t>(reshapedFilterRows, reshapedIPCols);
Conv3DReshapeFilter(FD, FH, FW, CI, CO, filterArr, filterReshaped);
Conv3DReshapeInput(N, D, H, W, CI, FD, FH, FW, zPadDLeft, zPadDRight, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, strideD, strideH, strideW, reshapedIPRows, reshapedIPCols, inputArr, inputReshaped);
MatMulCSF2D(reshapedFilterRows, reshapedFilterCols, reshapedIPCols, filterReshaped, inputReshaped, matmulOP, consSF);
Conv3DReshapeMatMulOP(N, newD, newH, newW, CO, matmulOP, outArr);
}

void Transpose2(int32_t s1, int32_t s2, auto& inArr, auto& outArr){
for (uint32_t i =  (int32_t)0; i < s1; i++){
for (uint32_t j =  (int32_t)0; j < s2; j++){
outArr[i][j] = inArr[j][i];
}
}
}

void Pad442(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t inps1, int32_t inps2, int32_t inps3, int32_t inps4, auto& inpArr, int32_t pads1, int32_t pads2, auto& paddings, auto& outArr){

int32_t lbounds1 = paddings[ (int32_t)0][ (int32_t)0];

int32_t rbounds1excl = (s1 - paddings[ (int32_t)0][ (int32_t)1]);

int32_t lbounds2 = paddings[ (int32_t)1][ (int32_t)0];

int32_t rbounds2excl = (s2 - paddings[ (int32_t)1][ (int32_t)1]);

int32_t lbounds3 = paddings[ (int32_t)2][ (int32_t)0];

int32_t rbounds3excl = (s3 - paddings[ (int32_t)2][ (int32_t)1]);

int32_t lbounds4 = paddings[ (int32_t)3][ (int32_t)0];

int32_t rbounds4excl = (s4 - paddings[ (int32_t)3][ (int32_t)1]);
for (uint32_t i =  (int32_t)0; i < s1; i++){
for (uint32_t j =  (int32_t)0; j < s2; j++){
for (uint32_t k =  (int32_t)0; k < s3; k++){
for (uint32_t l =  (int32_t)0; l < s4; l++){
if (((((((((i >= lbounds1) && (i < rbounds1excl)) && (j >= lbounds2)) && (j < rbounds2excl)) && (k >= lbounds3)) && (k < rbounds3excl)) && (l >= lbounds4)) && (l < rbounds4excl))) {
outArr[i][j][k][l] = inpArr[(i - paddings[ (int32_t)0][ (int32_t)0])][(j - paddings[ (int32_t)1][ (int32_t)0])][(k - paddings[ (int32_t)2][ (int32_t)0])][(l - paddings[ (int32_t)3][ (int32_t)0])];
} else {
outArr[i][j][k][l] = funcSSCons( (int64_t)0);
}
}
}
}
}
}

void Pad552(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t s5, int32_t inps1, int32_t inps2, int32_t inps3, int32_t inps4, int32_t inps5, auto& inpArr, int32_t pads1, int32_t pads2, auto& paddings, auto& outArr){

int32_t lbounds1 = paddings[ (int32_t)0][ (int32_t)0];

int32_t rbounds1excl = (s1 - paddings[ (int32_t)0][ (int32_t)1]);

int32_t lbounds2 = paddings[ (int32_t)1][ (int32_t)0];

int32_t rbounds2excl = (s2 - paddings[ (int32_t)1][ (int32_t)1]);

int32_t lbounds3 = paddings[ (int32_t)2][ (int32_t)0];

int32_t rbounds3excl = (s3 - paddings[ (int32_t)2][ (int32_t)1]);

int32_t lbounds4 = paddings[ (int32_t)3][ (int32_t)0];

int32_t rbounds4excl = (s4 - paddings[ (int32_t)3][ (int32_t)1]);

int32_t lbounds5 = paddings[ (int32_t)4][ (int32_t)0];

int32_t rbounds5excl = (s5 - paddings[ (int32_t)4][ (int32_t)1]);
for (uint32_t i =  (int32_t)0; i < s1; i++){
for (uint32_t j =  (int32_t)0; j < s2; j++){
for (uint32_t k =  (int32_t)0; k < s3; k++){
for (uint32_t l =  (int32_t)0; l < s4; l++){
for (uint32_t m =  (int32_t)0; m < s5; m++){
if (((((((((((i >= lbounds1) && (i < rbounds1excl)) && (j >= lbounds2)) && (j < rbounds2excl)) && (k >= lbounds3)) && (k < rbounds3excl)) && (l >= lbounds4)) && (l < rbounds4excl)) && (m >= lbounds5)) && (m < rbounds5excl))) {
outArr[i][j][k][l][m] = inpArr[(i - paddings[ (int32_t)0][ (int32_t)0])][(j - paddings[ (int32_t)1][ (int32_t)0])][(k - paddings[ (int32_t)2][ (int32_t)0])][(l - paddings[ (int32_t)3][ (int32_t)0])][(m - paddings[ (int32_t)4][ (int32_t)0])];
} else {
outArr[i][j][k][l][m] = funcSSCons( (int64_t)0);
}
}
}
}
}
}
}

void PadONNX441(int32_t o1, int32_t o2, int32_t o3, int32_t o4, int32_t i1, int32_t i2, int32_t i3, int32_t i4, auto& inpArr, int32_t pads, auto& paddings, auto& outArr){

int32_t lbounds1 = paddings[ (int32_t)0];

int32_t rbounds1excl = (o1 - paddings[ (int32_t)4]);

int32_t lbounds2 = paddings[ (int32_t)1];

int32_t rbounds2excl = (o2 - paddings[ (int32_t)5]);

int32_t lbounds3 = paddings[ (int32_t)2];

int32_t rbounds3excl = (o3 - paddings[ (int32_t)6]);

int32_t lbounds4 = paddings[ (int32_t)3];

int32_t rbounds4excl = (o4 - paddings[ (int32_t)7]);
for (uint32_t i =  (int32_t)0; i < o1; i++){
for (uint32_t j =  (int32_t)0; j < o2; j++){
for (uint32_t k =  (int32_t)0; k < o3; k++){
for (uint32_t l =  (int32_t)0; l < o4; l++){
if (((((((((i >= lbounds1) && (i < rbounds1excl)) && (j >= lbounds2)) && (j < rbounds2excl)) && (k >= lbounds3)) && (k < rbounds3excl)) && (l >= lbounds4)) && (l < rbounds4excl))) {
outArr[i][j][k][l] = inpArr[(i - paddings[ (int32_t)0])][(j - paddings[ (int32_t)1])][(k - paddings[ (int32_t)2])][(l - paddings[ (int32_t)3])];
} else {
outArr[i][j][k][l] = funcSSCons( (int64_t)0);
}
}
}
}
}
}

void Squeeze24(int32_t s1, int32_t s2, int32_t dim1, int32_t dim2, int32_t ins1, int32_t ins2, int32_t ins3, int32_t ins4, auto& inArr, auto& outArr){
for (uint32_t i =  (int32_t)0; i < ins1; i++){
for (uint32_t j =  (int32_t)0; j < ins2; j++){
for (uint32_t k =  (int32_t)0; k < ins3; k++){
for (uint32_t l =  (int32_t)0; l < ins4; l++){

int32_t linIdx = ((((((i * ins2) * ins3) * ins4) + ((j * ins3) * ins4)) + (k * ins4)) + l);

int32_t outIdx1 = (linIdx / s2);

int32_t outIdx2 = (linIdx % s2);
outArr[outIdx1][outIdx2] = inArr[i][j][k][l];
}
}
}
}
}

void ConvTranspose2DReshapeMatMulOP(int32_t N, int32_t finalH, int32_t finalW, int32_t CO, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t n =  (int32_t)0; n < N; n++){
for (uint32_t h =  (int32_t)0; h < finalH; h++){
for (uint32_t w =  (int32_t)0; w < finalW; w++){
outputArr[n][h][w][co] = inputArr[co][((((n * finalH) * finalW) + (h * finalW)) + w)];
}
}
}
}
}

void ConvTranspose2DReshapeFilter(int32_t FH, int32_t FW, int32_t CO, int32_t CI, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){

int32_t linIdx = ((((fh * FW) * CI) + (fw * CI)) + ci);
outputArr[co][linIdx] = inputArr[((FH -  (int32_t)1) - fh)][((FW -  (int32_t)1) - fw)][co][ci];
}
}
}
}
}

void ConvTranspose2DReshapeInput(int32_t N, int32_t HPrime, int32_t WPrime, int32_t CI, int32_t FH, int32_t FW, int32_t zPadTrHLeft, int32_t zPadTrHRight, int32_t zPadTrWLeft, int32_t zPadTrWRight, int32_t strideH, int32_t strideW, int32_t RRows, int32_t RCols, auto& inputArr, auto& outputArr){

int32_t linIdxFilterMult =  (int32_t)0;
for (uint32_t n =  (int32_t)0; n < N; n++){

int32_t leftTopCornerH = ( (int32_t)0 - zPadTrHLeft);

int32_t HPrimeTilde = (HPrime + ((HPrime -  (int32_t)1) * (strideH -  (int32_t)1)));

int32_t extremeRightBottomCornerH = ((HPrimeTilde -  (int32_t)1) + zPadTrHRight);
while ((((leftTopCornerH + FH) -  (int32_t)1) <= extremeRightBottomCornerH)) {

int32_t leftTopCornerW = ( (int32_t)0 - zPadTrWLeft);

int32_t WPrimeTilde = (WPrime + ((WPrime -  (int32_t)1) * (strideW -  (int32_t)1)));

int32_t extremeRightBottomCornerW = ((WPrimeTilde -  (int32_t)1) + zPadTrWRight);
while ((((leftTopCornerW + FW) -  (int32_t)1) <= extremeRightBottomCornerW)) {
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){

int32_t curPosH = (leftTopCornerH + fh);

int32_t curPosW = (leftTopCornerW + fw);

uint64_t val = funcSSCons( (int64_t)0);
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){
if ((((curPosH <  (int32_t)0) || (curPosH >= HPrimeTilde)) || ((curPosW <  (int32_t)0) || (curPosW >= WPrimeTilde)))) {
val = funcSSCons( (int64_t)0);
} else {
if ((((curPosH % strideH) ==  (int32_t)0) && ((curPosW % strideW) ==  (int32_t)0))) {

int32_t idxInputH = (curPosH / strideH);

int32_t idxInputW = (curPosW / strideW);
val = inputArr[n][idxInputH][idxInputW][ci];
} else {
val = funcSSCons( (int64_t)0);
}
}
outputArr[((((fh * FW) * CI) + (fw * CI)) + ci)][linIdxFilterMult] = val;
}
}
}
linIdxFilterMult = (linIdxFilterMult +  (int32_t)1);
leftTopCornerW = (leftTopCornerW +  (int32_t)1);
}

leftTopCornerH = (leftTopCornerH +  (int32_t)1);
}

}
}

void ConvTranspose2DCSF(int32_t N, int32_t HPrime, int32_t WPrime, int32_t CI, int32_t FH, int32_t FW, int32_t CO, int32_t H, int32_t W, int32_t zPadTrHLeft, int32_t zPadTrHRight, int32_t zPadTrWLeft, int32_t zPadTrWRight, int32_t strideH, int32_t strideW, auto& inputArr, auto& filterArr, int32_t consSF, auto& outArr){

int32_t reshapedFilterRows = CO;

int32_t reshapedFilterCols = ((FH * FW) * CI);

int32_t reshapedIPRows = ((FH * FW) * CI);

int32_t reshapedIPCols = ((N * H) * W);

auto filterReshaped = make_vector<uint64_t>(reshapedFilterRows, reshapedFilterCols);

auto inputReshaped = make_vector<uint64_t>(reshapedIPRows, reshapedIPCols);

auto matmulOP = make_vector<uint64_t>(reshapedFilterRows, reshapedIPCols);
ConvTranspose2DReshapeFilter(FH, FW, CO, CI, filterArr, filterReshaped);
ConvTranspose2DReshapeInput(N, HPrime, WPrime, CI, FH, FW, zPadTrHLeft, zPadTrHRight, zPadTrWLeft, zPadTrWRight, strideH, strideW, reshapedIPRows, reshapedIPCols, inputArr, inputReshaped);
MatMulCSF2D(reshapedFilterRows, reshapedFilterCols, reshapedIPCols, filterReshaped, inputReshaped, matmulOP, consSF);
ConvTranspose2DReshapeMatMulOP(N, H, W, CO, matmulOP, outArr);
}

void ConvTranspose3DReshapeFilter(int32_t FD, int32_t FH, int32_t FW, int32_t CO, int32_t CI, auto& inputArr, auto& outputArr){
for (uint32_t co =  (int32_t)0; co < CO; co++){
for (uint32_t fd =  (int32_t)0; fd < FD; fd++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){

int32_t linIdx = ((((((fd * FH) * FW) * CI) + ((fh * FW) * CI)) + (fw * CI)) + ci);
outputArr[co][linIdx] = inputArr[((FD -  (int32_t)1) - fd)][((FH -  (int32_t)1) - fh)][((FW -  (int32_t)1) - fw)][co][ci];
}
}
}
}
}
}

void ConvTranspose3DReshapeInput(int32_t N, int32_t DPrime, int32_t HPrime, int32_t WPrime, int32_t CI, int32_t FD, int32_t FH, int32_t FW, int32_t zPadTrDLeft, int32_t zPadTrDRight, int32_t zPadTrHLeft, int32_t zPadTrHRight, int32_t zPadTrWLeft, int32_t zPadTrWRight, int32_t strideD, int32_t strideH, int32_t strideW, int32_t RRows, int32_t RCols, auto& inputArr, auto& outputArr){

int32_t linIdxFilterMult =  (int32_t)0;
for (uint32_t n =  (int32_t)0; n < N; n++){

int32_t leftTopCornerD = ( (int32_t)0 - zPadTrDLeft);

int32_t DPrimeTilde = (DPrime + ((DPrime -  (int32_t)1) * (strideD -  (int32_t)1)));

int32_t extremeRightBottomCornerD = ((DPrimeTilde -  (int32_t)1) + zPadTrDRight);
while ((((leftTopCornerD + FD) -  (int32_t)1) <= extremeRightBottomCornerD)) {

int32_t leftTopCornerH = ( (int32_t)0 - zPadTrHLeft);

int32_t HPrimeTilde = (HPrime + ((HPrime -  (int32_t)1) * (strideH -  (int32_t)1)));

int32_t extremeRightBottomCornerH = ((HPrimeTilde -  (int32_t)1) + zPadTrHRight);
while ((((leftTopCornerH + FH) -  (int32_t)1) <= extremeRightBottomCornerH)) {

int32_t leftTopCornerW = ( (int32_t)0 - zPadTrWLeft);

int32_t WPrimeTilde = (WPrime + ((WPrime -  (int32_t)1) * (strideW -  (int32_t)1)));

int32_t extremeRightBottomCornerW = ((WPrimeTilde -  (int32_t)1) + zPadTrWRight);
while ((((leftTopCornerW + FW) -  (int32_t)1) <= extremeRightBottomCornerW)) {
for (uint32_t fd =  (int32_t)0; fd < FD; fd++){
for (uint32_t fh =  (int32_t)0; fh < FH; fh++){
for (uint32_t fw =  (int32_t)0; fw < FW; fw++){

int32_t curPosD = (leftTopCornerD + fd);

int32_t curPosH = (leftTopCornerH + fh);

int32_t curPosW = (leftTopCornerW + fw);

uint64_t val = funcSSCons( (int64_t)0);
for (uint32_t ci =  (int32_t)0; ci < CI; ci++){
if (((((curPosD <  (int32_t)0) || (curPosD >= DPrimeTilde)) || ((curPosH <  (int32_t)0) || (curPosH >= HPrimeTilde))) || ((curPosW <  (int32_t)0) || (curPosW >= WPrimeTilde)))) {
val = funcSSCons( (int64_t)0);
} else {
if (((((curPosD % strideD) ==  (int32_t)0) && ((curPosH % strideH) ==  (int32_t)0)) && ((curPosW % strideW) ==  (int32_t)0))) {

int32_t idxInputD = (curPosD / strideD);

int32_t idxInputH = (curPosH / strideH);

int32_t idxInputW = (curPosW / strideW);
val = inputArr[n][idxInputD][idxInputH][idxInputW][ci];
} else {
val = funcSSCons( (int64_t)0);
}
}
outputArr[((((((fd * FH) * FW) * CI) + ((fh * FW) * CI)) + (fw * CI)) + ci)][linIdxFilterMult] = val;
}
}
}
}
linIdxFilterMult = (linIdxFilterMult +  (int32_t)1);
leftTopCornerW = (leftTopCornerW +  (int32_t)1);
}

leftTopCornerH = (leftTopCornerH +  (int32_t)1);
}

leftTopCornerD = (leftTopCornerD +  (int32_t)1);
}

}
}

//void ConvTranspose3DCSF(int32_t N, int32_t DPrime, int32_t HPrime, int32_t WPrime, int32_t CI, int32_t FD, int32_t FH, int32_t FW, int32_t CO, int32_t D, int32_t H, int32_t W, int32_t zPadTrDLeft, int32_t zPadTrDRight, int32_t zPadTrHLeft, int32_t zPadTrHRight, int32_t zPadTrWLeft, int32_t zPadTrWRight, int32_t strideD, int32_t strideH, int32_t strideW, auto& inputArr, auto& filterArr, int32_t consSF, auto& outArr){

//int32_t reshapedFilterRows = CO;

//int32_t reshapedFilterCols = (((FD * FH) * FW) * CI);

//int32_t reshapedIPRows = (((FD * FH) * FW) * CI);

//int32_t reshapedIPCols = (((N * D) * H) * W);

//auto filterReshaped = make_vector<uint64_t>(reshapedFilterRows, reshapedFilterCols);

//auto inputReshaped = make_vector<uint64_t>(reshapedIPRows, reshapedIPCols);

//auto matmulOP = make_vector<uint64_t>(reshapedFilterRows, reshapedIPCols);
//ConvTranspose3DReshapeFilter(FD, FH, FW, CO, CI, filterArr, filterReshaped);
//ConvTranspose3DReshapeInput(N, DPrime, HPrime, WPrime, CI, FD, FH, FW, zPadTrDLeft, zPadTrDRight, zPadTrHLeft, zPadTrHRight, zPadTrWLeft, zPadTrWRight, strideD, strideH, strideW, reshapedIPRows, reshapedIPCols, inputArr, inputReshaped);
//MatMulCSF2D(reshapedFilterRows, reshapedFilterCols, reshapedIPCols, filterReshaped, inputReshaped, matmulOP, consSF);
//Conv3DReshapeMatMulOP(N, D, H, W, CO, matmulOP, outArr);
//}

void ClearMemPublic(int32_t x){
return ;
}

void ClearMemPublic1(int32_t s, auto& x){
return ;
}

void ClearMemPublic4(int32_t s1, int32_t s2, int32_t s3, int32_t s4, auto& arr){
return ;
}

void ClearMemPublic5(int32_t s1, int32_t s2, int32_t s3, int32_t s4, int32_t s5, auto& arr){
return ;
}



void my_Conv3DSliding(int32_t N, int32_t D, int32_t H, int32_t W, int32_t CI, int32_t FD, int32_t FH, int32_t FW, int32_t CO, int32_t zPadDLeft, int32_t zPadDRight, int32_t zPadHLeft, int32_t zPadHRight, int32_t zPadWLeft, int32_t zPadWRight, int32_t strideD, int32_t strideH, int32_t strideW, int32_t outD, int32_t outH, int32_t outW, auto& inputArr, auto& filterArr, int32_t consSF, auto& outArr){
#pragma omp parallel for collapse(5)
        for (uint32_t n =  (int32_t)0; n < N; n++){
                for (uint32_t co =  (int32_t)0; co < CO; co++){
                        for (uint32_t d =  (int32_t)0; d < outD; d++){
                                for (uint32_t h =  (int32_t)0; h < outH; h++){
                                        for (uint32_t w =  (int32_t)0; w < outW; w++){
                                                for (uint32_t ci =  (int32_t)0; ci < CI; ci++){
                                                        int64_t val =  (int64_t)0;
                                                        for (uint32_t fd = (d * strideD); fd < ((d * strideD) + FD); fd++){
                                                                for (uint32_t fh = (h * strideH); fh < ((h * strideH) + FH); fh++){
                                                                        for (uint32_t fw = (w * strideW); fw < ((w * strideW) + FW); fw++){
                                                                                int32_t curPosD = (fd - zPadDLeft);
                                                                                int32_t curPosH = (fh - zPadHLeft);
                                                                                int32_t curPosW = (fw - zPadWLeft);
                                                                                if (((((((curPosD >=  (int32_t)0) && (curPosH >=  (int32_t)0)) && (curPosW >=  (int32_t)0)) && (curPosD < D)) && (curPosH < H)) && (curPosW < W))) {

                                                                                        int32_t curFilterPosD = (fd - (d * strideD));

                                                                                        int32_t curFilterPosH = (fh - (h * strideH));

                                                                                        int32_t curFilterPosW = (fw - (w * strideW));
                                                                                        val = (val + (inputArr[n][curPosD][curPosH][curPosW][ci] * filterArr[curFilterPosD][curFilterPosH][curFilterPosW][ci][co]));
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                        outArr[n][d][h][w][co] = (outArr[n][d][h][w][co] + (val >> consSF));
                                                }
                                        }
                                }
                        }
                }
        }
}

void Conv3DSliding_wrapper(
        int32_t N,
        int32_t D,
        int32_t H,
        int32_t W,
        int32_t CI,
        int32_t FD,
        int32_t FH,
        int32_t FW,
        int32_t CO,
        int32_t zPadDLeft,
        int32_t zPadDRight,
        int32_t zPadHLeft,
        int32_t zPadHRight,
        int32_t zPadWLeft,
        int32_t zPadWRight,
        int32_t strideD,
        int32_t strideH,
        int32_t strideW,
        vector< vector< vector< vector< vector<porthosSecretType> > > > >& inputArr,
        vector< vector< vector< vector< vector<porthosSecretType> > > > >& filterArr,
        int32_t consSF,
        vector< vector< vector< vector< vector<porthosSecretType> > > > >& outArr) {

        int32_t outD = ((((D - FD) + (zPadDLeft + zPadDRight)) / strideD) +  (int32_t)1);
        int32_t outH = ((((H - FH) + (zPadHLeft + zPadHRight)) / strideH) +  (int32_t)1);
        int32_t outW = ((((W - FW) + (zPadWLeft + zPadWRight)) / strideW) +  (int32_t)1);
        my_Conv3DSliding(N, D, H, W, CI, FD, FH, FW, CO, zPadDLeft, zPadDRight, zPadHLeft, zPadHRight, zPadWLeft, zPadWRight, strideD, strideH, strideW, outD, outH, outW, inputArr, filterArr, consSF, outArr);
}

extern int instanceID;
int main(int argc, char** argv)
{
parseInputs(argc, argv);
string whichNetwork = "Your Network";
show_porthos_mode();
string indep_key_location, common_key_location;
if(partyNum == PARTY_A){
indep_key_location = "files/keyA";
common_key_location = "files/keyAB";
}
else if(partyNum == PARTY_B){
indep_key_location = "files/keyB";
common_key_location = "files/keyAB";
}
else{
indep_key_location = "files/keyB";
common_key_location = "files/keyAB";
}
aes_indep = new AESObject(indep_key_location);
aes_common = new AESObject(common_key_location);
aes_a_1 = new AESObject("files/keyD");
aes_a_2 = new AESObject("files/keyD");
aes_b_1 = new AESObject("files/keyD");
aes_b_2 = new AESObject("files/keyD");
aes_c_1 = new AESObject("files/keyD");
aes_share_conv_bit_shares_p0_p2 = new AESObject("files/keyD");
aes_share_conv_bit_shares_p1_p2 = new AESObject("files/keyD");
aes_share_conv_shares_mod_odd_p0_p2 = new AESObject("files/keyD");
aes_share_conv_shares_mod_odd_p1_p2 = new AESObject("files/keyD");
aes_comp_msb_shares_lsb_p0_p2 = new AESObject("files/keyD");
aes_comp_msb_shares_lsb_p1_p2 = new AESObject("files/keyD");
aes_comp_msb_shares_bit_vec_p0_p2 = new AESObject("files/keyD");
aes_comp_msb_shares_bit_vec_p1_p2 = new AESObject("files/keyD");
aes_conv_opti_a_1 = new AESObject("files/keyD");
aes_conv_opti_a_2 = new AESObject("files/keyD");
aes_conv_opti_b_1 = new AESObject("files/keyD");
aes_conv_opti_b_2 = new AESObject("files/keyD");
aes_conv_opti_c_1 = new AESObject("files/keyD");
aes_parallel = new ParallelAESObject(common_key_location);

if (MPC)
{
initializeMPC();
initializeCommunication(argv[2], partyNum);
synchronize(2000000); 
}

if (PARALLEL) aes_parallel->precompute();
e_role role = partyNum;
if (role==CLIENT){
    srand(8000);
}
else if (role == SERVER){
    srand(8777);
}
else{
    srand(9333);
}

auto tmp0 = make_vector<uint64_t>( (int32_t)1,  (int32_t)4,  (int32_t)16,  (int32_t)16,  (int32_t)512);
/* Variable to read the clear value corresponding to the input variable tmp0 at (1123,1-1123,45) */
uint64_t __tmp_in_tmp0;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)4; i1++){
for (uint32_t i2 =  (uint32_t)0; i2 <  (int32_t)16; i2++){
for (uint32_t i3 =  (uint32_t)0; i3 <  (int32_t)16; i3++){
for (uint32_t i4 =  (uint32_t)0; i4 <  (int32_t)512; i4++){
if ((role == CLIENT)) {
    tmp0[i0][i1][i2][i3][i4] = 1ULL<<24;
}
else{
    tmp0[i0][i1][i2][i3][i4] = 2ULL<<24;
}
}
}
}
}
}


auto tmp1 = make_vector<uint64_t>( (int32_t)4,  (int32_t)4,  (int32_t)4,  (int32_t)256,  (int32_t)512);
/* Variable to read the clear value corresponding to the input variable tmp1 at (1126,1-1126,45) */
uint64_t __tmp_in_tmp1;
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)4; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)4; i1++){
for (uint32_t i2 =  (uint32_t)0; i2 <  (int32_t)4; i2++){
for (uint32_t i3 =  (uint32_t)0; i3 <  (int32_t)256; i3++){
for (uint32_t i4 =  (uint32_t)0; i4 <  (int32_t)512; i4++){
if ((role == SERVER)) {
    tmp1[i0][i1][i2][i3][i4] = 3ULL<<24;
}
else{
    tmp1[i0][i1][i2][i3][i4] = 2ULL<<24;
}
}
}
}
}
}

StartComputation();

auto tmpimg = make_vector<uint64_t>( (int32_t)1,  (int32_t)4,  (int32_t)16,  (int32_t)16,  (int32_t)512);
auto tmpweights = make_vector<uint64_t>( (int32_t)4,  (int32_t)4,  (int32_t)4,  (int32_t)256,  (int32_t)512);

// for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
// for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)4; i1++){
// for (uint32_t i2 =  (uint32_t)0; i2 <  (int32_t)16; i2++){
// for (uint32_t i3 =  (uint32_t)0; i3 <  (int32_t)16; i3++){
// for (uint32_t i4 =  (uint32_t)0; i4 <  (int32_t)512; i4++){
// tmpimg[i0][i1][i2][i3][i4] = (funcReconstruct2PCCons(tmp0[i0][i1][i2][i3][i4], 2));
// }
// }
// }
// }
// }

// for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)4; i0++){
// for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)4; i1++){
// for (uint32_t i2 =  (uint32_t)0; i2 <  (int32_t)4; i2++){
// for (uint32_t i3 =  (uint32_t)0; i3 <  (int32_t)256; i3++){
// for (uint32_t i4 =  (uint32_t)0; i4 <  (int32_t)512; i4++){
// tmpweights[i0][i1][i2][i3][i4] = (funcReconstruct2PCCons(tmp1[i0][i1][i2][i3][i4], 2));
// }
// }
// }
// }
// }

// auto tmpoutput = make_vector<uint64_t>( (int32_t)1,  (int32_t)10,  (int32_t)34,  (int32_t)34,  (int32_t)256);
// ConvTranspose3DLoop(1,  4,  16,  16,  512,  
//                     4,  4,  4,  256,  
//                     10,  34,  34,  
//                     3,  3,  3,  3,  3,  3,  
//                     2,  2,  2, 
//                     tmpimg, tmpweights, tmpoutput
//                     );

// for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
// for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)10; i1++){
// for (uint32_t i2 =  (uint32_t)0; i2 <  (int32_t)34; i2++){
// for (uint32_t i3 =  (uint32_t)0; i3 <  (int32_t)34; i3++){
// for (uint32_t i4 =  (uint32_t)0; i4 <  (int32_t)256; i4++){
// cout << (((int64_t)(tmpoutput[i0][i1][i2][i3][i4]))>>24) << endl;
// }
// }
// }
// }
// }
//EndComputation();
cout << "----------------------------------" << endl;
cout << "----------------------------------" << endl;
cout << "----------------------------------" << endl;


auto tmp2 = make_vector<uint64_t>( (int32_t)1,  (int32_t)10,  (int32_t)34,  (int32_t)34,  (int32_t)256);
ConvTranspose3DCSFMPC( (int32_t)1,  (int32_t)4,  (int32_t)16,  (int32_t)16,  (int32_t)512,  (int32_t)4,  (int32_t)4,  (int32_t)4,  (int32_t)256,  (int32_t)10,  (int32_t)34,  (int32_t)34,  (int32_t)3,  (int32_t)3,  (int32_t)3,  (int32_t)3,  (int32_t)3,  (int32_t)3,  (int32_t)2,  (int32_t)2,  (int32_t)2, tmp0, tmp1,  (int32_t)24, tmp2);
// ClearMemSecret5( (int32_t)1,  (int32_t)2,  (int32_t)5,  (int32_t)5,  (int32_t)1, tmp0);
// ClearMemSecret5( (int32_t)2,  (int32_t)3,  (int32_t)3,  (int32_t)1,  (int32_t)1, tmp1);
// EndComputation();
for (uint32_t i0 =  (uint32_t)0; i0 <  (int32_t)1; i0++){
for (uint32_t i1 =  (uint32_t)0; i1 <  (int32_t)10; i1++){
for (uint32_t i2 =  (uint32_t)0; i2 <  (int32_t)34; i2++){
for (uint32_t i3 =  (uint32_t)0; i3 <  (int32_t)34; i3++){
for (uint32_t i4 =  (uint32_t)0; i4 <  (int32_t)256; i4++){
cout << (int64_t)(funcReconstruct2PCCons(tmp2[i0][i1][i2][i3][i4], 2)) << endl;
}
}
}
}
}
EndComputation();
cout << "----------------------------------" << endl;
cout << NUM_OF_PARTIES << "PC code, P" << partyNum << endl;
cout << NUM_ITERATIONS << " iterations, " << whichNetwork << endl;
cout << "----------------------------------" << endl << endl;


/****************************** CLEAN-UP ******************************/
delete aes_common;
delete aes_indep;
delete aes_a_1;
delete aes_a_2;
delete aes_b_1;
delete aes_b_2;
delete aes_c_1;
delete aes_share_conv_bit_shares_p0_p2;
delete aes_share_conv_bit_shares_p1_p2;
delete aes_share_conv_shares_mod_odd_p0_p2;
delete aes_share_conv_shares_mod_odd_p1_p2;
delete aes_comp_msb_shares_lsb_p0_p2;
delete aes_comp_msb_shares_lsb_p1_p2;
delete aes_comp_msb_shares_bit_vec_p0_p2;
delete aes_comp_msb_shares_bit_vec_p1_p2;
delete aes_conv_opti_a_1;
delete aes_conv_opti_a_2;
delete aes_conv_opti_b_1;
delete aes_conv_opti_b_2;
delete aes_conv_opti_c_1;
delete aes_parallel;
deleteObjects();

return 0;

}

